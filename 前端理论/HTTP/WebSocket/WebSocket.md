## WebSocket

WebSocket是目前基于HTML5提出的一个协议，为了实现客户端和服务器端的长连接而设计的。由于HTTP/1.1仅仅能够用keep-alive头部来模拟长连接，并不能够实现真正的长连接。

### HTTP/1.1 Keep-Alive

HTTP在刚开始的时候，对于每一次的HTTP请求，都需要打开一个TCP连接，然后在请求完成之后，关闭这个连接。所以下一次再需要请求的时候，需要再打开一次TCP连接。每一次TCP连接都需要握手来建立通信，所以这样就浪费了很多建立连接的带宽，并且也消耗了服务器的资源。

由于一个页面的许多资源可能都来自一个或者较少的几个站点，这叫做站点局部性，所以保持长连接可以较好的利用已经建立起来的TCP连接，还可以避免慢启动所带来的网络拥塞的风险，直到客户端或者服务器主动将这个持久的TCP连接关闭，否则两者之间的HTTP都可以复用这个连接。

#### 老版本的Keep-Alive

对于HTTP/1.0来说，不是所有的连接都被认为是`Keep-Alive`的，所以需要通过设置首部来启用，当客户端对服务器发起请求的时候，会添加一个首部字段`Connection: Keep-Alive`，表示客户端想要和服务器建立长连接。这时，如果服务器的响应首部上也包含该首部字段，那么表示服务器会与客户端建立持久连接，并且可以通过首部字段`Keep-Alive: max=5, timeout=120`来设置连接的持续时间。否则，客户端会直接断开和服务器的TCP连接。

#### HTTP/1.1的Keep-Alive

到了HTTP/1.1，长连接的机制和1.0有一些不同，其默认使用Keep-Alive，除非某一方发送了`Connection: close`首部字段，才会将原本建立的TCP连接关闭。

HTTP的长连接可以实现一次TCP连接，进行多次的HTTP通信，提高了连接的利用效率，但是并不能实现服务器端的推送，推送仍然要靠客户端的长轮询来实现。也就是让客户端不停地请求服务器，达到数据随时更新的目的。但是这样会占用很多的服务器资源，效率比较低，而且很多的轮询请求都是没有用的，但是服务器仍然需要处理这个请求。

### WebSocket

WebSocket在一定程度上还是基于HTTP协议的，HTTP协议通过`Upgrade: websocket`首部字段来表示客户端想要使用WebSocket来建立连接，服务器端会根据客户端的请求对通信的协议进行升级，返回`101 Switching Protocols`状态码，表示切换当前的协议。这样就完成了一次WebSocket的握手，从HTTP将协议升级为了WebSocket。

并且WebSocket连接的通信信道是全双工的，也就是可以在接收消息的同时发送消息，并且实现了服务端到客户端的消息推送。但是也有一点小问题，那就是建立的这个连接会保持下去，这样也会占用服务端的一些资源，但是比起长轮询来说效率要高很多了。