## GET/POST的区别以及RESTful设计风格

### GET/POST

在进行HTTP协议的网络请求的时候，最常使用的两个请求方法就是GET和POST，这两个请求方法基本涵盖了当前互联网中大部分的应用层请求。这两个请求方法在语义层面和在实现层面都有着一些区别。

#### Specification语义

在RFC规范中对于这两个请求方法的使用方式和使用场景都有着规范化的定义。在规范中，这两个请求方法应该需要被完全分离考虑的，没有一个场景是可以通用两种方法的。在语义规范中，GET请求方法应该只进行对于目标内容的获取操作，而POST方法应该只对目标进行更新。

在语义规范中，这两者有着下面的区别：

>1. 安全性
>
>   诸如GET、OPTIONS、HEAD这样的方法，在实现的时候应该是安全的，这里的安全主要意味着其对于目标服务器上的资源是只读的，也就是该操作没有副作用，这样一个请求就可以进行多次提交，而不对目标服务器造成不可预料的结果。
>
>2. 幂等性
>
>   GET请求应该是幂等的，也就是多次在不同环境下对同一个服务器的相同请求应该得到的是相同的结果。这样保证了多个客户端对于同一资源的请求结果。
>
>3. 可缓存性
>
>   GET请求应该是可以缓存的。

虽然在RFC规范中，两个请求是这样定义的，但是在大多数情况下，服务端，客户端的开发人员并不能够完全遵守语义，甚至于在浏览器的实现中，很多内容都不能够完全符合语义，或者浏览器为了可操作性在其中添加了新的功能。

#### Implementation实现

在实际情况中，各种对于HTTP请求方法语义的实现并不可能完全按照标准，所以一些浏览器厂商或者开发人员在开发的时候可能会不得不违背语义。比如在POST操作的时候仍然会获取一些数据内容，比如在GET请求的时候，仍会修改服务器上的某些状态。

流于表面的两者之间的区别主要有下面这些：

1. GET请求调用刷新页面的时候无害，而POST数据会被重新提交。
2. GET书签可以收藏，因为GET请求的URL如果不进行跳转则会保留在地址栏中。
3. GET请求的参数由于是URL参数，会被保留在浏览器历史中。
4. GET请求由于采用URL参数，所以会导致数据长度有限制，而POST则可以发送较大量的数据。
5. GET请求的隐私性较差，而POST请求的隐私性更好。
6. POST请求不会被缓存，这也是为什么AJAX采用POST请求来进行，GET请求如果想要其不备缓存，则需要在其后加一个根据时间生成的随机数或者时间戳。

#### 实际

在实际情况中，开发者对于GET和POST请求的语义的概念已经模糊了，在进行用户登录操作的时候，有时候不得不对服务器端产生一些副作用，比如记录用户登录状态、登录日志等，即使这个操作是使用GET请求进行的。

*但是为了代码的清晰或者逻辑上的正确，在使用HTTP请求的时候还是应该分清每种请求方法的语义上的区别*，比如获取最新的一些数据信息，这情况下尽量使用GET请求，如果需要做一些带有副作用的操作，还是选择POST请求比较好。

### RESTful设计风格

RESTful是为了现代web系统的接口通用化，以及可扩展性而设计的一种专门的api设计风格，由于现在web的前后端分离，所以，客户端、移动端、web端三端可以开始使用标准的接口了。对于服务器提供的公共服务，只要这三端采用相同的调用方式，那么整个互联网的客户端可以只需要一套server的服务就可以实现数据的操作。这样service无论是在开发成本或者是维护性、扩展性上都有了显著的提升。

* 首先，server不应该保存任何状态，server对于请求的响应应该完全基于client提供的内容。这样在api调用的时候，server可以进行一致的处理操作。
* 对于所操作的资源应该由URL完全指定。为了区分资源的来源，URL应该明确指定使用的资源到底是什么资源，然后与状态进行合并，来进行数据的操作。由于指定的是resource，所以URL应该使用名词来进行标识，并且建议使用复数，比如`myServer.com/api/users`或者`myServer.com/api/users?userid=2`。
* 对于操作的类型，也就是动词，应该由请求方法进行完全指定。比如对于资源的更新操作应该使用`POST`请求，获取某些资源的操作应该使用`GET`请求，状态可以通过cookie或者url参数来进行指定。
* 对于数据的类型，应该通过MIME类型来进行标识，对于GET请求，使用`Accpet`首部来告知server自己需要的数据类型。而POST请求则使用`Content-Type`来指定提交的数据类型。

在server和client分层之后，client处理基本的业务逻辑，server也分为两层，数据模型model和提供api的业务逻辑。这样，当数据结构发生了变化的时候，只需要修改server上的model层，而不需要动其他的地方，当某些通用业务逻辑发生了变化的时候，server上的service提供者是唯一需要修改的地方，这样将业务进行解耦，让每一个部分的功能更加清晰也便于维护。