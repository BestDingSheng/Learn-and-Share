## RegExp

JavaScript正则表达式的构建方法有两种，一种是通过正则表达式字面量进行构建的，而另外一种则是通过`RegExp`这个构造函数，也就是封装对象的方法进行构建。但是如果需要动态构建正则表达式的话，也就是表达式内部的值需要通过变量来获取，那么就需要使用构造函数来构建。

```javascript
// 这两种方法是等价的。
var regExp = new RegExp('xyz', i);
var regExp = /xyz/i;
```

### 正则对象

通过上面的两个构建方法，可以得到一个正则对象，这个对象有一些属性和方法。

其中，修饰符属性可以用来配置当前正则表达式的一些匹配规则。这个修饰符和构建正则表达式的时候传入的修饰符的功能是一致的。

> 1. `ignoreCase`：这个修饰符用来确定是否忽略大小写；
> 2. `global`：这个修饰符表示是否进行全局匹配，如果不使用该修饰符，那么匹配操作会在第一次匹配成功的时候停止。
> 3. `multiline`：这个操作符表示多行模式，开启后`$`和`^`操作符会自动匹配每一行的行尾和行首。

还有两个不太常用的属性：

> 1. `lastIndex`：表示上一次匹配结束的位置，也就是这一次匹配开始的位置。
> 2. `source`：返回正则表达式的字符串形式：不包含反斜杠符号。

### 匹配方法

对于字符串进行匹配的时候，有两种方法，一种方法是以正则表达式为对象，调用其上的方法，另外一种是以字符串为对象，调用字符串方法传入正则来匹配。

#### 正则匹配方法

##### `test`

正则对象的`test()`方法返回一个布尔值，表示当前的正则是否能够匹配参数字符串。

这个是最简单的正则匹配方法了。如果没有全局修饰符，那么每次的匹配都是从头开始，否则会从上一次匹配的结束位置开始。

##### `exec`

正则对象的`exec()`方法可以返回匹配的结果，如果发现了一个匹配，那么就返回一个数组，数组成员是每一个匹配上了的结果。

如果正则表达式中包含组匹配的话，那么最后的匹配结果仍然是一个数组，数组的第一个元素是整个匹配得到的结果，后面的每个参数都是一个组的匹配结果。

```javascript
var str = 'This is a string';
var reg = /(T|t)his is a (S|s)tring/g;
console.log(reg.exec(str));
// ["This is a string", "T", "s", index: 0, input: "This is a string"];
```

除了数组的内容外，这个数组上还有两个额外的属性：

> 1. `index`：表示成功匹配的开始的位置。
> 2. `input`：表示整个源字符串。

如果有全局修饰符的话，那么再次调用匹配方法，会从上次结束的地方开始继续进行匹配。

#### 字符串匹配方法

##### `String.prototype.match()`

这个方法可以对字符串进行正则匹配，将正则表达式通过参数传入。

`match`方法和`exec`方法的操作类似，匹配成功返回一个数组，否则返回一个`null`。

如果带有`g`修饰符的话，那么和`exec`不同的是，不需要进行多次的匹配，只需要一次就可以返回所有的匹配结果。并且不会返回源字符串和匹配的字符串，只会返回匹配的结果。

##### `String.prototype.search()`

这个方法会返回第一个符合模式的结果在字符串中的位置，如果不存在的话那么就会返回`-1`。这个方法的形式和`indexOf`类似，不过匹配的参数变成了正则表达式。

*这个方法会忽略`g`修饰符。*

##### `String.prototype.replace()`

这个方法可以用来替换匹配了的值。*如果不加`g`修饰符，那么就替换第一个匹配成功的值，否则替换所有匹配成功的值。*

`$`符号可以在第二个参数中指代正则表达式中的组。

> 1. `$&`指代匹配的子字符串
> 2. $\`和`$'`分别指代匹配结果前后的文本
> 3. `$n`指代匹配的结果中的组

第二个参数还可以是一个函数，对于每个匹配的内容调用函数，并且将匹配内容替换为函数返回值。

这个函数具有的参数个数和匹配结果有关，第一个参数是匹配到的内容，第二至多个参数是捕捉到的匹配组，最后的参数是匹配的内容在字符串中的位置和源字符串。

```javascript
var str = 'Hello World';
var reg = /([A-Z])([a-z])/g;
var replaceStr = str.replace(reg, function(match, $1, $2) {
  return `-${$1}-${$2}-`;
});
// -H-e-llo -W-o-rld
```

##### `String.prototype.split()`

这个方法返回一个按照正则规则分割的字符串数组，这个方法接收两个参数，第一个是分割规则，第二个是返回的数组的最大成员数。

如果正则表达式带有括号分组，那么括号匹配的部分也会作为数组成员返回。

### 匹配规则

#### 字面量字符和元字符

大部分字符在正则表达式中，代表的都是其字面上的含义。然而有一部分字符在正则表达式中有一些其他的含义，这些字符叫做元字符。

1. `.`点字符匹配除了回车`\r`,换行`\n`,行分隔符`\u2028`,段分隔符`\u2029`之外的所有字符。
2. `^`和`$`字符分别可以匹配字符串的开始和结束，或者是每一行的开始和结束。
3. `|`字符在正则表达式中表示或关系。这个符号会自动匹配其前后的多个字符，这个问题可以用圆括号来修复。

#### 转义符

一些特殊字符，也就是在正则表达式中有特殊意义的字符，需要首先被转义，才能表示其本来的含义。

这样的字符在正则表达式中有：^ . [ $ ( ) | * + ? { \\

如果是通过构造函数定义的正则表达式，那么反斜杠需要先被转义。然后再做转义符使用。

#### 特殊字符

正则表达式对一些不能够打印的特殊字符，也提供了匹配，比如

`\n`匹配换行符

`\r`匹配回车

`\t`匹配制表符等

#### 字符类

放在方括号中的字符，只需要匹配到其中的一个就可以了，所有可选择的字符都放在方括号里面。

如果方括号中的第一个字符是`^`，则表示除了字符类中的字符，其他字符都可以匹配。比如`[^xyz]`表示匹配除了xyz之外的其他所有字符。

如果方括号内没有其他任何字符，那么`[^]`就表示匹配任意一个字符。

#### 预定义模式

预定义模式指某些常见模式的简写方式。

比如：

> 1. \d，表示匹配0-9的任意数字
> 2. \D，表示匹配除了0-9之外的任意数字
> 3. \w，表示匹配任意的字母，数字和下划线
> 4. \W，表示除了数字、字母下划线之外的所有字符
> 5. \s，表示所有的空格字符
> 6. \S，表示所有的非空格字符
> 7. \b，匹配一个词的边界
> 8. \B，匹配非词的边界

#### 重复类

大括号中的数字表示之前的字符的重复次数，如果只有一个数字，表示重复次数，如果是逗号分隔的两个数字，那么表示重复次数的一个范围。

`*`号表示重复0次或者多次，等同于`{0,}`

`?`号表示重复0次或者1次，等同于`{0, 1}`

`+`号表示重复1次或者多次，等同于`{1,}`

对于这些重复类来说，正则表达式有两种匹配方法，*贪婪方式表示会一直匹配到不能够匹配为止，默认为贪婪模式。*例如，`a+`匹配`aaaaa`字符串，贪婪模式会匹配所有的字符串，但是非贪婪模式只会匹配1个就停止。非贪婪模式用一个后缀的问号启动。

#### 分组匹配

用小括号包起来的正则片段会作为整体匹配，并且匹配的结果会被记录下来，可以通过`\n`来在正则中继续引用，其中n为大于1的自然数。

比如：`/y((..)\2)\1/`，这个正则内部括号为2号分组，表示匹配两个非换行符，然后`\2`表示对分组2的重复，而`\1`表示对于外部括号的分组1的重复，这样匹配的结果是，两个字符的词重复4次。

##### 非捕获组

如果不需要捕获这个组的内容，分组只是用来进行合并的话，那么使用`(?:)`开头的分组定义方式就可以了。

##### 先行断言

`x(?=y)`表示只有x在y的前面的时候，x才会被匹配，但是y不会被计入匹配结果中。

##### 先行否定断言

`x(?!y)`表示只有x不在y的前面的时候，x才会被匹配，但是y不会计入匹配结果中。

```javascript
// 先行断言
var m = 'abc'.match(/b(?=c)/);
// ['b']
// 先行否定断言
var m = 'abc'.match(/b(?!c)/);
// null
```

