## JavaScript垃圾回收

### 内存泄漏

对于C语言这种需要程序员自己在代码中释放内存的语言来说，*如果不主动进行无用变量的内存释放*，很快就会导致一些无用的变量占据内存，导致可用内存减少的情况，这种情况称为内存泄漏。

但是对于大部分的现代编程语言来说，其语言本身就提供了自动的内存管理，这个内存管理方法称为“垃圾回收机制”。

### 垃圾回收机制

#### 引用计数

最简单的垃圾回收的方式是引用计数，在语言的引擎内部，有一张引用计数表，当一个值的引用次数为0的时候，表示这个值不会被再用到，这时候这个值所占的内存就可以被释放了。

当然，被定义为局部变量的值会在代码块结束的时候解除引用，而全局变量的值只有在其被主动删除或者是关闭窗口的时候才会被解除引用。

```javascript
// 这个数组被arr变量引用了，所以其引用计数为1，不会被释放
let arr = [1, 2, 3, 4];
// some code here
// 这里arr改变了其引用，导致数组的引用计数变为0，所以这个数组的空间被释放了
arr = null;
// 函数作用域在退出了时候会对作用域内部变量的引用计数进行清理
function count() {
  var c = 2;
  return d = {
    c
  }
}
var a = count();
// 上面代码中，由于函数内部一个变量被返回，所以形成了闭包，其内部被引用过的引用计数还在，不能够被释放，这也是闭包的一个缺点
```

但是引用计数有一个很大的问题，在函数内部如果有循环引用，那么在函数退出的时候其空间也不会被释放。

```javascript
// 这个函数在退出之后，由于两个对象互相引用了对方，所以即使函数退出了，其引用计数也不为0，所以不会被释放。
function count() {
  var a = {};
  var b = {};
  b.a = a;
  a.b = b;
}
```

#### 标记清除

标记清除方法总共有两个阶段：标记阶段和清除阶段。

标记阶段会对整个内存堆栈进行分析，将当前运行环境可达的变量标记为可达对象。

清除阶段将内存中所有的未标记成可达对象的变量进行回收。

由于这个方法是全局性的，对于整个内存进行操作，所以在进行标记清除的时候，整个程序会被中断，然后直到内存清理完成才会继续执行，并且产生了内存碎片。

### WeakMap和WeakSet

由于引用计数的问题，在ES6的Map和Set数据结构中，可以使用对象或者各种变量作为键，以对象为键的时候，由于键本身就对于对象产生了引用，即使这个变量被重新赋值，但是响应的键还在引用，就导致了这个内存不会被释放。

```javascript
const map = new Map();
let obj = {};
map.set(obj, 'this is an empty object!');
// 这里虽然释放了对象变量，但是由于map还在引用，所以这个对象不会真正被释放，只是无法进行引用了而已，但是其仍在会在内存中，造成了内存泄漏
obj = null;
```

而使用WeakSet和WeakMap，这两个数据结构和Set以及Map的区别在于其使用的是弱引用，也就是这两个数据结构对于其他对象的引用是不会被引用计数计算在内的。当其他引用被释放后，这个引用并不会阻止内存的释放。

```javascript
const weakMap = new WeakMap();
let obj = {};
map.set(obj, 'this is an empty object!');
// 这样释放了对象后，其实内存已经被释放了，只是无法进行测试而已
obj = null;
```

这些弱引用的数据结构可以很好的防止出现内存泄漏的过程，但是对于一些不再使用的对象，还是需要手动将其引用计数清空，一般可以使用赋值的方式情况：

```javascript
let arr = [1,2,3,4];
arr = null;
// 使用完了一个非简单类型的数据，最好将其清空
```