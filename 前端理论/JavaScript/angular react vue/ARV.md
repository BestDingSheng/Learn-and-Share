## Angular2、React and Vue

### 应用范围

目前来说，这三个框架其实都是使用在同一个领域的，那就是Web应用。Angular目前的适用范围相比其他两个要窄一些，React可以使用服务端渲染，并且有移动端版本的React Native来适配，而Vue是一个比较轻量级的框架，技术栈比起React来说要小很多，并且代码和功能都相对简单一些，并且也有移动端的Weex框架可以使用。当业务逻辑比较轻的时候使用Vue是更好的选择。

### Web应用的三个问题

Web应用中的问题主要分为三类：效率、组织和状态，分别对应着表现，维护以及业务逻辑。由于Web应用现在主要是单页模式，所以初始加载速度可以在一定程度上进行一些妥协，来保证后面操作的流畅，单页应用的效果类似于原生的客户端应用，在客户端应用打开的时候，用户可以忍受一定的加载时间，但是在开始使用的时候，用户不希望在每次切换路由的时候都需要大量的数据或者是页面的加载时间。这一点，和传统的多页面结构是不同的。

刚开始的单页应用模式主要是通过AJAX实现的，在服务端对页面的数据进行加载，并且渲染，将渲染好的页面通过AJAX实现不刷新页面的嵌入。而近几年的几个框架的出现，将前后端实现完全的分离，后端面对客户端以及前端提供一样的API来进行调用，前端通过后端获取的数据进行渲染，这样保证了后端的一致性。jQuery通过快速的便捷的DOM操作也在一段时间内成为了单页应用的构建方式。但是jQuery仍旧是直接对DOM进行的操作，数据层和表现层仍然耦合在一起，并且这样的DOM操作速度仍旧是很慢的，于是出现了很多MVC、MVVM框架，来将数据、表现、控制进行分离。现在的三种框架都使用了组件化开发，将所有DOM操作的逻辑基本都封装在了库中，不需要手动进行DOM操作，每层的职责更加统一，可以更好的进行单元测试以及开发。

#### 状态

在单页应用中，界面和数据是相互影响的，存在从数据到界面的映射，当界面发生改变时，比如用户的点击操作，界面到数据也是存在映射的，和当前显示的界面有映射关系的那部分数据就是状态。

对于一个规模比较大的单页应用来说，比如一个blog，可能需要这样的状态：

```json
{
  "user": [
    {
      "userid": 1,
      "userName": "Lucas",
      "age": 20
    },
    {
      // 可能有很多需要加载的用户信息
    }
  ],
  "passage": [
    {
      "passageContent": "adada",
      "passageAuthor": 4,
      "passagePrefer": [1, 2, 3, 4, 5],
      "passageDislike": [20, 21]
    }
    // 可能有很多需要加载的文章信息
  ],
  "current": {
    "user": 1,
    "passage": 4,
    "status": "writing"
    // 可能有很多和当前界面有关的信息，这些信息会依赖其他的数据项
  },
  // 还可能有更多的状态来帮助渲染和业务逻辑，比如：推荐、相关、广告、评论等等
}
```

这样的状态已经是进行过范式化了，尽量保证在有数据更新的时候，可以更改更少的数据内容。[State范式化](http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html)

可以看到状态可能仍旧很庞大，所以对于状态的抽象是很重要的，将状态抽象成一个完整的类似数据库的结构，在数据发生改变的时候，状态可以更加清晰的反映出数据的变化。

三种框架对于状态的控制是不太一样的，对于MVVM模式的Angular和Vue，通过模板语法，来表示界面和数据的关系，当界面发生改变的时候，根据规则映射到相应的数据，再通过模板给定的规则来更新对应的界面。这种数据更新方式是*双向数据绑定*。

而React使用的函数式的单项数据流，使用有限状态机的原理，通过当前的状态以及对于当前状态上施加的变化，来生成一个新的状态，然后这个状态会导致界面的更新。

RxJS使用响应式的概念，将所有的数据变化看做一个Stream，也就是Observable。需要订阅该状态的界面会订阅这个Stream或者是几个Stream的各种耦合形成的一个新的Stream，当Stream发生变化的时候，耦合生成的Stream也会随着变化，那么订阅了状态的界面也会进行更新。而界面的更新也会修改状态，所以也可以看做是一个Stream。

总结一下，*双向数据绑定*，*Redux单向数据流*，*RxJS的Observable响应式*。

#### 组织

代码的组织直接影响的代码迭代时候的效率以及单元测试的准确程度。几个框架对于应用的组织都是一致的，那就是组件化。  

##### 组件化的优劣

组件化的优势是显而易见，就是提升了开发和维护的效率。以React为例，从最底层的展示型组件开始，底层的组件不带有任何页面逻辑，仅仅负责界面的渲染工作，使用`PureComponent`进行初始化，上层的组件逐渐带上业务逻辑。这样当需要修改某个地方的样式的时候，可以迅速定位到需要修改的展示型组件上，并且将状态切分成一个个数据块进行管理，也在一定程度上提高了组件的复用性。这一个过程和搭积木是类似的。

组件化的成本主要在于：

1. 开发周期：组件的拆分也是需要一定时间的，小粒度的组件远没有大粒度的组件开发起来那么快，需要层层耦合。需要对组件的可复用性进行权衡，对于复用性较高的组件花费较长时间是划算的。
2. 实现难度：组件化需要团队的配合，以及总体的规划能力。
3. 继承难度：组件化和其他异构系统耦合起来会导致很别扭。

##### 组件化的实践

1. 组件树的层级：组件树的层级不要过于深了，最好是3~5层之内，否则数据在组件间的通信负担很大。
2. 组件间的通信：如何在几种组件的通信方式中进行选择。
3. 组件的继承：实现组件的继承的代价比较大，而且很可能在`render`方法里面还需要一定的重写，在大部分情况下不如组合效率高。

##### 业务逻辑

业务模型是业务数据、规则、流程的集合，即使没有展示层的存在，业务层应该也是可以独立运作的。组件在层层堆叠起来的时候会生成一棵组件树，组件之间也需要相互通信，大部分情况下是上层到下层的通信，但是有些时候会出现下层到上层之间的通信，甚至是同层组件、跨越几层组件的通信。在业务层比较厚重的情况下这些通信如果没有良好的组织，会导致逻辑的混乱，所以才出现了Flux以及Flux的实践Redux。

Redux、RxJS这些数据流方案的出现就是进行组件化数据流的结构化工作的。

#### 效率

效率分为开发效率和运行效率：

##### 开发效率

组件化是提升开发效率的一种很好的途径，最底层代码的耦合度较低，每个组件可以有不同的人并行开发不会产生干扰。组件化也是这三个框架都实现了的东西。

##### 运行效率

Angular的脏检测机制是运行效率比较低的一个。但是Angular2将脏检测放到了WebWorker中进行，对于高版本的浏览器效率很高。

虚拟DOM的机制是React最开始实现的，现在Vue中也加入了虚拟DOM的机制，但angular2目前还未实现，所以Vue和React的DOM创建效率和修改效率会高一些。

