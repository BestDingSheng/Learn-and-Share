## yahoo前端优化

### 减少HTTP请求条数

由于现代浏览器的并行条数是有限制的，每个浏览器的限制不一样，前端页面的显示速度的瓶颈在很多时候都是页面上各种资源的加载速度，资源越多，由于并行条件的限制，那么就需要多次串行HTTP请求才能够完成。

#### 处理方法

1. 使用sprite图，也就是将图片整合到一张图片上，然后通过背景图片的大小和位置来分别显示。
2. 行内图片，使用Base64编码的图片来进行显示，但是这样文档会过重，并且会影响缓存，所以最好放在可以缓存的CSS里面。
3. 合并脚本和CSS。webpack可以很好的实现脚本和CSS等各种文件的打包。

针对减少HTTP请求数是提升页面第一次访问速度的很好的方法，因为在第一次访问的时候是不存在缓存的，所有的页面资源都要从网络上面加载。而对于一个网站来说，第一次访问的用户以及缓存已经过期的用户占的比例是很大的。

### 使用CDN

属于服务器方面的优化，在各个地理位置部署缓存服务器，使用户能够从物理上最近的位置获取到资源。

### 添加Expire或者Cache-Control HTTP头

属于服务器的优化，现在请求的资源越来越多，当用户不是第一次访问该页面的时候，很多可以复用的资源需要靠缓存来使用。使用缓存的主要方式就是浏览器缓存，可以让用户在本地读取想要的内容。

缓存是有有效期的。对于一些基本不太需要改变的静态资源，最好为其设置一个较长的有效期。`Cache-Control`的优先级要高于`Expires`，可以设置其`max-age`字段来表示过期时间。对于可能会经常变化的动态资源，还是为其设置一个合理长度的有效期，可以在保证资源有效的情况下，实现最好的性能。

`ETag`也是使用缓存必不可少的一个部分，这个首部能够为缓存文件提供一种验证机制。当缓存过期了的时候，需要对缓存的有效性进行验证。缓存过期之后，客户端会将缓存的资源的`ETag`内容发送到服务端，如果服务端验证后发现并未过期，那么就可以修改当前资源的有效时间，来让缓存继续可用，否则就重新发送一个该资源给客户端。

### Gzip组件

HTTP支持的包压缩可以对于响应的包进行压缩，来保证能够接收到比较小的报文。压缩的报文在客户端进行解压缩。

当发送HTTP请求的时候，客户端会为请求中添加一个`Accept-Encoding`首部，会要求服务器对响应报文进行压缩，服务器通过响应报文中的`Content-Encoding`首部来告知客户端其所使用的压缩方式，来让客户端完成解压。当前最好的压缩方式是`Gzip`方式。

这种压缩对于文本资源的压缩效果比较明显，比如，脚本、文档、样式表、JSON等，但是图片等资源已经被压缩过了，所以可以不用进行压缩。

### 样式表放在顶部

浏览器对于资源的加载是根据文档解析的过程来的，当文档解析到一个资源的时候，其会向服务端请求该资源，如果将外部样式表放在文档的底部，那么文档在快要解析完的时候才会请求样式表，这样文档可能在render树构建到一半或者快要构建完成的时候才能开始解析样式表，这样会导致页面进行大规模回流，因为这时候已经完成了一部分组件的布局和绘制。

将样式表放在文档的`head`标签中，可以让页面更快加载到样式，并且构建渲染树的时候可以根据外部样式表来进行构建，布局和绘制，不会导致大规模的回流，并且可以最快让用户看到具有样式的页面。

### 脚本放在底部

脚本会阻塞页面的渲染，如果将脚本放在页面首部的话，那么页面会在脚本执行完成后再开始渲染，这样用户会看到长时间的空白页面。并且脚本还会阻塞其他资源的并行下载。

如果脚本非要放在头部的话。那么可以给脚本加上`defer`，表示脚本的延迟执行，这样脚本会在文档完成解析后开始执行，或者加上`async`，这样脚本会放在一个单独的线程中执行，异步的效率更好。但是很多兼容性较差，因为*IE 10*才开始支持。

### 不要使用CSS表达式

*不要使用CSS表达式，因为它会造成无限多次重复计算。从而可能导致渲染回流或者重绘。*

### 外部CSS和脚本

使用外部资源还是内联资源，其实就是首次访问和之后访问的一个衡量，合理使用内联资源，可以减少加载外部资源的时间，提升首次访问时候的加载速度，而使用外部资源，可以更好的利用缓存，在用户之后访问同一个页面的速度进行了优化。

目前衡量的最优结果是，对于一般的网站，其主页使用大量的内联样式和脚本，实现最快速度的加载，之后的页面中可以复用的资源使用外联模式。这样可以很好的利用缓存。

### 减少DNS

每次资源请求都会进行一次DNS查找，除非请求的时候，该DNS信息已经缓存了起来，一般DNS会在浏览器中被缓存一小段时间的，所以理论上说，如果所有资源都来自于同一个主机，那么只需要一次DNS查找就可以了，但是单一主机又限制了资源并行下载的并行度，所以均衡这两点，最好将所有的资源分布在2~4个主机下面，对DNS查找和并发下载进行折中。

### 压缩JavaScript和CSS

压缩可以从代码中去除不必要的字符来减少大小，提升页面的加载速度。主要包括对变量名的修改(混淆)，去掉空格换行等空白字符，现在这个功能可以通过webpack这种打包工具来实现。

### 避免重定向

重定向会返回一个301或者302的状态码，并且在首部`Location`中包含目前资源所在的位置。浏览器会自动进行跳转。这样就会多一次HTTP请求，并且在这个阶段，用户的页面是空白的。

在能够避免重定向的情况下尽量避免，如果实在不能够避免，那么就使用标准的重定向状态码301或者302来进行重定向。

### 对AJAX使用GET请求

GET请求的速度要快于POST请求，POST请求会首先发送一个HTTP报文头，然后再发送数据，而GET请求由于不需要发送数据，所以只需要一次TCP就可以了。

在符合HTTP说明的情况下，如果无法抉择使用哪种请求方法，那么就使用GET吧，可以在一定程度上提升请求的速度。将需要发送的内容放到GET请求的URL中进行发送，但是要注意URL的长度是有限制的。

### 延迟加载组件

某些组件可以进行延迟进行加载，因为部分组件在页面初始化渲染的时候是不需要的。比如一些隐藏元素或者是折叠起来的图片等等。

一些事件处理或者动画可以在页面完全绘制完毕之后再进行加载，让用户能够优先看到一些自己想要看到的东西。剩下的可以放在绘制完毕之后触发的`onload`事件之后再进行加载。

### 尽量减少DOM元素的数量

不要为了修改样式而添加很多无用的DOM元素，这些元素在添加的时候可能感觉没什么，但是在浏览器构建DOM树以及render树的时候，其效率可能就会被很明显的表现出来。并且在构建render树的时候，需要进行CSS样式的匹配，这些匹配规则也是需要遍历DOM的，如果DOM元素过多，那么也会增加元素匹配时候的时间的。

对于JavaScript来说，有时候需要获取DOM元素的内容，或者为其添加事件处理函数，那么过多的DOM元素也会导致脚本的速度更慢，这时候需要使用更加具有语义化的HTML标签，可以加快查找速度，有效的减少DOM元素的数量，并且更好的利用浏览器在渲染页面时候的优化。

这里知乎文章页、腾讯首页、阮一峰的博客页三个页面都有大概2000多个标签，而知乎有200个左右div，看起来内容很多的腾讯首页有500个div，而阮一峰的博客有将近1000个div标签。

#### 减少DOM访问

除了减少DOM元素的数量，使用JavaScript对于DOM的访问和操作也应该减少，不提JavaScript操作DOM造成的回流问题，其访问速度也是很慢的。

* 缓存已经访问过的元素，或者对于即将要多次访问的元素进行缓存。
* 如果必须要更新节点，那么可以首先将这个元素离线，对其进行修改，然后再将其挂载进去，这样可以减少可能出现的回流次数。
* 使用CSS class来进行样式的修复。修改元素的class属性，只会导致一次样式的切换，这样只会出现一次回流，如果动态地为元素添加效果，那么每次操作都可能会引起一次回流，这样直接导致了布局发生多次变化，提高了计算量。

### 减小cookie

cookie是HTTP用来保存状态的一个主要工具，甚至于session也是用cookie实现的。但是如果cookie存在的话，那么客户端发送到服务端的请求中都会将cookie放在请求首部中。所以要保证cookie尽可能的小，来减少进行HTTP请求的时间。

*将页面和组件分域名放置也是一个减小cookie的方法*，由于cookie的作用域为当前指定的域名以及其子域名，所以这样对于资源的请求就不会带上cookie了，而正常的获取数据的请求还是可以带上cookie。但是这样做的成本也会稍微高一些，需要进行衡量。

### 使用事件委托

有时候页面反应的不灵敏是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上。这种时候可以对能够统一处理的事件进行提升，为其组件元素添加事件监听。

并且不要为了处理DOM而等待`onload`事件，因为目标元素只要在DOM树中就可以访问了，不需要等待所有资源下载完成。

### 针对图片的优化

* 除非是动画图片，否则尽量不要使用GIF，最好使用PNG图片，可以更好地支持透明度。
* 不要使用HTML来缩放图片，比如，如果需要显示一个100\*100的图片，那么就去加载一个100\*100的图片，而不是为了达到同样的目的，而去缩放一个400\*400的图片。
* 优化CSS Sprite，使用横向Sprite图，并且不要在Sprite图片中间留下太大间隙。
* 用小的可缓存的favicon.ico，这个文件是用来当标签和收藏夹图标的，浏览器会默认请求这个图片，所以最好设置好缓存的HTTP头，来保证不需要经常请求该文件，并且这个图片要足够小，最好在1K以下。

### 避免图片的src属性为空

当图片的`src`属性为空字符串的时候，浏览器会向服务器发送另外一个请求。

在HTML5中，如果出现了这种情况，那么浏览器是不会发送一个额外的请求的，但是规范要求`src`属性必须存在，并且有一个合法的URL来进行资源的交互。

