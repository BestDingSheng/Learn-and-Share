### 函数式编程的思维
范畴轮 
1 函数式编程是范畴轮的数学分支是一门很复杂的数学，认为世界上所有的概念体系都可以抽象出一个范畴
2 彼此之间存在某种关系概念 事物 对象等等 都构成范畴 。任何事物只要找出他们之间的关系 就能定义
3 箭头表示范畴成员之间的关系 正式名称叫做 态射 。范畴轮认为，同一个范畴的所有成员 就是不同态射的变形，通过态射，一个成员可以变形成灵一个成员

### 函数式编程基础理论

1 函数式编程其实对于计算机的历史而言是一个古老的概念，甚至早于第一台计算机的诞生。韩式是编程的基础模型来源kambda的演算，而演算并非设计于在计算机上执行，他是在20世纪三十年代引入的一套用于研究函数定义 函数应用和递归形式的系统。
2 函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数合成简单的函数（计算理论 或者递归轮 或者拉姆达演算）运算过程劲量写成一系列嵌套函数调用
3 Javascript 是披着C外衣的lisp
4 真正的火热是随着react的高阶函数而逐步升温

1 函数式一等公民。所谓 第一等公民 指的是函数与其他数据类型一样 处于平等地位，可以复制给其他变量也可以作为参数传入另一个函数，或者作为别的函数的返回值；
2 不可改变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数替代了了；在函数式编程中变量仅仅代表某个表达式。这里所说的变量是不能被修改的 所有的变量只能被赋一次初值；
3 map 和reduce他们是最常见的函数式编程的方式

### 函数式编程的核心概念 
- 纯函数
- 函数的柯里化
- 函数组合
- Point Free
- 声明式于命令式代码
- 惰性求值

### 纯函数
对于相同的输入 永远会得到相同的输出 而且没有任何可观察的副作用 也不依赖外部的环境状态。

### 函数柯里化
传递给函数的一部分参数来调用他，让他返回一个函数去处理剩下的参数
```js
    // 柯里化之前
    function add(x,y){
        return x+y;
    }
    add(1,2);
 // 柯里化之后
    function add(x){
        return function(y){
            return x+y;
        }
    }
    add(1)(2)

    // 柯里化的话 代码可以缓存
    var result = add(1);
    reuslt(2) // 3

```
#### 柯里化的优点
事实上柯里化是一个预加载函数的方式，通过传递较少的参数得到一个已经记住了这些参数的新函数，某种意义上讲 这是一种对参数的 缓存，是一个非常高效的编写函数方法

### 函数组合
纯函数以及如何把他柯里化写出洋葱代码h(g(f(x)))为了解决函数嵌套的问题，我们需要用到函数组合；

### Poiint Free
把一些对象自带的方法转化成春函数，不要命名转瞬即逝的中间变量。
这个中间变量除了让代码变得长了一点异味是毫无意义的
```js
    const = str=>str.toUppercase().split('');

```

### 声明式和命令式代码

命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一半都会涉及到很多复杂的细节。
而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的提示。

```js
    // 命令式
    let ceos=[];
    for(var i=0;i<companies.length;i++){
        ceos.push(companies[i].ceo)
    }

    // 声明式
    let ceso = companies.map(function(c){
        return c.ceo
    })

```
#### 优缺点

函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的春函数，我们完全可以不考虑函数内部是如何实现的
专注于编写业务代码，优化代码时 目光只需要几种在这些稳定坚固的函数内部即可。

相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是需要考虑这些不干净的副作用。
在复杂的系统中，这对于程序员的心智来说是极大地负担；

### 惰性求值、惰性函数

在指令式语言中一下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行；

## 更加专业的术语
- 高阶函数
- 尾调用优化
- 闭包
- 容器、Functor
- 错误处理 Either、 AP
- IO
- Monad


### 高阶函数

函数当参数 ，把传入的函数做一个封装 ，然后返回这个封装函数，打到更高程的抽象。

```js
   var add = function(a,b){
       return a+b;
   }
   function math(func,array){
        return func(array[0],array[1]);
   }

   math(add,[1,2])

```

### 尾调用优化

指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。
函数调用自身称为递归。如果是尾调用自身，就称尾递归。
递归需要保存大量的调用记录，很容易发生栈溢出错误了。


